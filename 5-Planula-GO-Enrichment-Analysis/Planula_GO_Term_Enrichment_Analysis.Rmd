---
title: "Planula GO Term Enrichment Analysis"
author: "Erin Chille"
date: "2021/02/16"
output: html_document
---

Load necessary libraries
```{r}
library(goseq)
library(tidyverse)
library(GSEABase)
library(data.table)
library(ggplot2)
library(cowplot)
library(gridExtra)
```

Import the data files 
```{r}
#treatment information
treatmentinfo <- read.csv("Sample_Info/RNAseq_data.csv", header = TRUE, sep = ",")
str(treatmentinfo)
head(treatmentinfo)

#gene count matrix
gcount <- as.data.frame(read.csv("2-QC-Align-Assemble/Output/gene_count_matrix.csv", row.names="gene_id"))
gcount <- gcount[ ,treatmentinfo$sample_id] #remove samples not in the treatment information csv (i.e. not in experiment)
gcount$gene_id <- rownames(gcount)
rownames(gcount) <- NULL
dim(gcount)

#DESeq2 and clustering results
DEG.res <- read.csv("4-Differential-Gene-Expression-Analysis/Output/pln_DEGs_all.csv")[,-1]
nrow(DEG.res)

#filter DEGs for log2FoldChange>|1|
DEG.res <- filter(DEG.res, log2FoldChange > 1 | log2FoldChange < (-1))
nrow(DEG.res)

#transcript annotations
annot <- read_tsv( "1-BLAST-GO-KO/Output/200824_Mcap_Blast_GO_KO.tsv", col_names = TRUE) #biological annotation information
Go.ref <- subset(annot, select= c(gene_id, length)) #Select only relevant information

#Filter gcount by available annotations
Go.ref <- merge(gcount, Go.ref, by = "gene_id")
```

Make a dataframe containing the gene_ids and cluster for each cluster.
```{r}
#Select only gene_id and cluster from DEseq2 res
DEGclust <- subset(DEG.res, select=c(gene_id, cluster))
DEGclust <- unique(DEGclust)

clust1 <- filter(DEGclust, cluster=="1")
nrow(clust1) #nrow clust1
clust2 <- filter(DEGclust, cluster=="2")
nrow(clust2) #nrow clust2
```

Set ID and gene length vectors, and make a binary matrix indicating which genes are differentially expressed. These are used as input to nullp, which for calculates a Probability Weighting Function for each set of DEGs.
```{r}
#Make ID and length vectors
Go.ref <- unique(Go.ref)
dim(Go.ref)
IDvector <- Go.ref$gene_id
lengthVector <- Go.ref$length

#Cluster 1
clust1.genes <- as.vector(clust1$gene_id)
clust1.genes=as.integer(Go.ref$gene_id%in%clust1.genes)
names(clust1.genes)=Go.ref$gene_id
length(clust1.genes)
length(names(clust1.genes))
length(unique(names(clust1.genes)))

#Cluster 2
clust2.genes <- as.vector(clust2$gene_id)
clust2.genes=as.integer(Go.ref$gene_id%in%clust2.genes)
names(clust2.genes)=Go.ref$gene_id
length(clust1.genes)

pwf.C1<-nullp(DEgenes=clust1.genes, id=IDvector, bias.data=lengthVector) #weight vector by length of gene
pwf.C2<-nullp(clust2.genes, IDvector, bias.data=lengthVector) #weight vector by length of gene
```

Prepare GO term dataframe
```{r}
GO.annot <- subset(annot, select=c(gene_id, GO_IDs))
GO.annot.na <- filter(GO.annot, GO_IDs!="NA;NA") #Remove NAs
GO.annot.na$GO_IDs <- gsub("NA;", "", GO.annot.na$GO_IDs)  #Remove NAs
GO.annot.na$GO_IDs <- gsub(";NA", "", GO.annot.na$GO_IDs)  #Remove NAs
splitted <- strsplit(as.character(GO.annot.na$GO_IDs), ";") #split into multiple GO ids
GO.terms <- data.frame(v1 = rep.int(GO.annot.na$gene_id, sapply(splitted, length)), v2 = unlist(splitted)) #list all genes with each of their GO terms in a single row
colnames(GO.terms) <- c("gene_id", "GO.ID")

GO.terms$GO.ID<- as.character(GO.terms$GO.ID)
GO.terms$GO.ID <- replace_na(GO.terms$GO.ID, "unknown")
GO.terms$GO.ID <- as.factor(GO.terms$GO.ID)
GO.terms$gene_id <- as.factor(GO.terms$gene_id)
GO.terms$GO.ID <- gsub(" ", "", GO.terms$GO.ID)
GO.terms <- unique(GO.terms)

dim(GO.terms)
head(GO.terms, 10)

nrow(GO.terms)/length(unique(GO.terms$gene_id)) #avg GO IDs per gene
```

Find enriched GO terms, "selection-unbiased testing for category enrichment amongst significantly expressed genes for RNA-seq data"
```{r, warning=FALSE, message=FALSE}
GOwall.C1 <- goseq(pwf.C1, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.C2 <- goseq(pwf.C2, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
```

Find only enriched GO terms that are statistically significant at cutoff
```{r}
C1.GO.05<-GOwall.C1$category[GOwall.C1$over_represented_pvalue<.05]
C1.GO.05<-data.frame(C1.GO.05)
colnames(C1.GO.05) <- c("category")
C1.GO.05 <- merge(C1.GO.05, GOwall.C1, by="category")
C1.GO.05 <- C1.GO.05[order(C1.GO.05$ontology, C1.GO.05$over_represented_pvalue, -C1.GO.05$numDEInCat),]
C1.GO.05$term <- as.factor(C1.GO.05$term)
nrow(filter(C1.GO.05, ontology=="BP")) #number sig BP terms
nrow(filter(C1.GO.05, ontology=="MF")) #number sig MF terms
nrow(C1.GO.05)

C2.GO.05<-GOwall.C2$category[GOwall.C2$over_represented_pvalue<.05]
C2.GO.05<-data.frame(C2.GO.05)
colnames(C2.GO.05) <- c("category")
C2.GO.05 <- merge(C2.GO.05, GOwall.C2, by="category")
C2.GO.05 <- C2.GO.05[order(C2.GO.05$ontology, C2.GO.05$over_represented_pvalue, -C2.GO.05$numDEInCat),]
C2.GO.05$term <- as.factor(C2.GO.05$term)
nrow(filter(C2.GO.05, ontology=="BP")) #number sig BP terms
nrow(filter(C2.GO.05, ontology=="MF")) #number sig MF terms
nrow(C2.GO.05)
```

Correct any un-annotated terms/ontologies
```{r}
NAs.ontology <- C1.GO.05 %>% subset(is.na(term))
print(NAs.ontology)
NAs.ontology <- C2.GO.05 %>% subset(is.na(term))
print(NAs.ontology)
```
*There were no un-annotated functions except genes with unknown functions*

Save significant terms
```{r, warning=FALSE}
write.csv(C1.GO.05, file = "5-Planula-GO-Enrichment-Analysis/Output/GO.05.C1.csv", row.names = FALSE)
write.csv(C2.GO.05, file = "5-Planula-GO-Enrichment-Analysis/Output/GO.05.C2.csv", row.names = FALSE)
```

## Find GOslim terms

Read in files if previous steps not run.
```{r}
C1.GO.05 <- read_csv("5-Planula-GO-Enrichment-Analysis/Output/GO.05.C1.csv")
C1.GO.05$dir <- "C1 (Up)"
C2.GO.05 <- read_csv("5-Planula-GO-Enrichment-Analysis/Output/GO.05.C2.csv")
C2.GO.05$dir <- "C2 (Down))"
all_GO <- bind_rows(C1.GO.05, C2.GO.05)  #bind rows
str(all_GO)
```

Run GOslim to get broader categories
```{r}
slim <- getOBOCollection("http://current.geneontology.org/ontology/subsets/goslim_generic.obo") #get GO database

## BP
BP_GO <- all_GO %>%
  filter(ontology=="BP")
BPGO_collection <- GOCollection(BP_GO$category) #Make library of query terms
slims_bp <- data.frame(goSlim(BPGO_collection, slim, "BP")) #Find common parent terms to slim down our list
slims_bp$category <- row.names(slims_bp) #save rownames as category

## MF
MF_GO <- all_GO %>%
  filter(ontology=="MF")
MFGO_collection <- GOCollection(MF_GO$category) #Make library of query terms
slims_mf <- data.frame(goSlim(MFGO_collection, slim, "MF")) #Find common parent terms to slim down our list
slims_mf$category <- row.names(slims_mf) #save rownames as category
```

Get mapped terms, using functions from Sam White's Biostars [post](https://support.bioconductor.org/p/128407/#128409).
```{r}
#Write function mappedIds to get the query terms that mapped to the slim categories
mappedIds <-
  function(df, collection, OFFSPRING) #the command to run requires a dataframe of slim terms, like slims_MF above, your list of query terms, and the offspring from the GOCollection by goSlim
  {
    map <- as.list(OFFSPRING[rownames(df)]) # Subset GOcollection offspring by the rownames of your dataframe
    mapped <- lapply(map, intersect, ids(collection)) #Find the terms that intersect between the subset made above of your query terms and the GOids from the GO collection
    df[["go_terms"]] <- vapply(unname(mapped), paste, collapse = ";", character(1L)) #Add column "go_terms" with matching terms 
    df #show resulting dataframe
  }
#Run function for MF and BP terms
BPslim <- mappedIds(slims_bp, BPGO_collection, GOBPOFFSPRING)
MFslim <- mappedIds(slims_mf, MFGO_collection, GOMFOFFSPRING)
```
Remove duplicate matches, keeping the broader umbrella term
```{r}
#BP
BPslim <- filter(BPslim, Count>0 & Term!="biological_process") #filter out empty slims and term "biological process"
BPsplitted <- strsplit(as.character(BPslim$go_terms), ";") #split into multiple GO ids
BPslimX <- data.frame(Term = rep.int(BPslim$Term, sapply(BPsplitted, length)), go_term = unlist(BPsplitted)) #list all
BPslimX <- merge(BPslimX, BPslim[,c(1,3:4)], by="Term") #Add back counts, term, and category info
BPslimX <- unique(setDT(BPslimX)[order(go_term, -Count)], by = "go_term") #remove duplicate offspring terms, keeping only those that appear in the larger umbrella term (larger Count number)
BPslim <- data.frame(slim_term=BPslimX$Term, slim_cat=BPslimX$category, category=BPslimX$go_term) #rename columns
head(BPslim)

#MF
MFslim <- filter(MFslim, Count>0 & Term!="molecular_function") #filter out empty slims and term "molecular function"
MFsplitted <- strsplit(as.character(MFslim$go_terms), ";") #split into multiple GO ids
MFslimX <- data.frame(Term = rep.int(MFslim$Term, sapply(MFsplitted, length)), go_term = unlist(MFsplitted)) #list all
MFslimX <- merge(MFslimX, MFslim[,c(1,3:4)], by="Term")  #Add back counts, term, and category info
MFslimX <- unique(setDT(MFslimX)[order(go_term, -Count)], by = "go_term")  #remove duplicate offspring terms, keeping only
MFslim <- data.frame(slim_term=MFslimX$Term, slim_cat=MFslimX$category, category=MFslimX$go_term) #rename columns
head(MFslim)
```
Save slim info with GO enrichment info for heatmap dataframes.
```{r}
GO.BP <- right_join(BPslim, filter(all_GO, ontology=="BP"), by="category") #add back GO enrichment info for each offspring term
GO.MF <- right_join(MFslim, filter(all_GO, ontology=="MF"), by="category") #add back GO enrichment info for each offspring term
```

## Make heatmap
```{r}
BPplot <- GO.BP %>% filter(numInCat>5) %>% ggplot(aes(x = dir, y = term)) + 
  geom_tile(aes(fill=over_represented_pvalue, width = 1)) + 
  facet_grid(slim_term ~ ontology, scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
  strip.text.y = element_text(angle=0, size = 11, face = "bold"),
  strip.text.x = element_text(size = 12, face = "bold"),
  axis.title.x = element_blank(),
  axis.title.y = element_text(size=15),
  axis.text = element_text(size = 12), legend.position = "None",
  plot.margin = unit(c(0,1,0,0.25), "cm"))

MFplot <- GO.MF %>% filter(numInCat>5) %>% ggplot(aes(x = dir, y = term)) + 
  geom_tile(aes(fill=over_represented_pvalue, width = 1)) + 
  scale_y_discrete(position = "right") +
  facet_grid(slim_term ~ ontology, scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE), 
             switch="y") + #Put the y facet strips on the left
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
  strip.text.y.left = element_text(angle=0, size = 11, face = "bold"),
  strip.text.x = element_text(size = 12, face = "bold"),
  axis.title = element_blank(),
  axis.text = element_text(size = 12), legend.title = element_text(size = 12), legend.text = element_text(size = 11))

fig5 <- grid.arrange(BPplot, MFplot, ncol = 2, nrow = 1, widths = c(4.25,7), clip = "off")
fig5 <- ggdraw(plot = fig5) + draw_plot_label(c("a)", "b)"), c(0, 0.38), c(1, 1), size = 15)
ggsave("5-Planula-GO-Enrichment-Analysis/Output/fig5_GOslim.pdf", fig5, width = 20, height = 20, units = c("in"))
ggsave("Final_figures/Fig5.png", fig5, width = 20, height = 20, units = c("in"))
```

## Make supplemental table summarizing GO enrichment
```{r}
DF_GOhm <- bind_rows(GO.BP, GO.MF)
head(DF_GOhm)
```

